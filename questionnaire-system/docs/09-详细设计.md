# 问卷系统详细设计文档

## 第5章 详细设计

### 5.1 前台用户端详细设计

#### 5.1.1 用户认证模块

##### 5.1.1.1 用户注册功能

**1. 功能描述**

用户注册功能允许新用户通过填写用户名、邮箱、密码等信息创建账号。系统对用户输入进行严格验证,确保用户名和邮箱的唯一性,并使用 bcrypt 算法对密码进行加密存储。注册成功后,系统自动为新用户赠送 100 积分作为注册奖励,生成默认头像,并立即签发 JWT Token 实现自动登录。

**2. 业务流程与代码逻辑**

用户注册的业务流程如下:

```
用户提交注册表单
    ↓
前端表单验证(用户名、密码格式)
    ↓
发送 POST 请求到 /api/auth/register
    ↓
后端验证用户名是否已存在
    ↓
后端验证邮箱是否已存在(如果提供)
    ↓
密码加密处理(bcrypt, 10轮加盐)
    ↓
创建用户记录(User 表)
  - ID: 时间戳生成
  - 初始积分: 100
  - 默认头像: DiceBear API 生成
  - 角色: user
    ↓
记录积分历史(PointHistory 表)
  - 积分: +100
  - 原因: "注册奖励"
  - 类型: earn
    ↓
生成 JWT Token
  - Payload: { id, role }
  - 密钥: JWT_SECRET
  - 过期时间: 7天
    ↓
返回 Token 和用户信息
    ↓
前端存储 Token 到 localStorage
    ↓
自动跳转到首页
```

核心代码逻辑:

```javascript
// 1. 检查用户名唯一性
const existingUsername = await User.findOne({
  where: { username }
});
if (existingUsername) {
  return res.status(400).json({
    success: false,
    message: "用户名已存在，请重新输入"
  });
}

// 2. 检查邮箱唯一性
if (email) {
  const existingEmail = await User.findOne({
    where: { email }
  });
  if (existingEmail) {
    return res.status(400).json({
      success: false,
      message: "邮箱已存在"
    });
  }
}

// 3. 创建用户(密码加密由 Sequelize hooks 自动处理)
const user = await User.create({
  id: Date.now().toString(),
  username,
  email: email || `${username}@example.com`,
  password,  // hooks 会自动加密
  nickname: nickname || username,
  points: 100,
  avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${username}`
});

// 4. 记录积分历史
await PointHistory.create({
  id: `ph_${Date.now()}`,
  userId: user.id,
  points: 100,
  reason: "注册奖励",
  type: "earn"
});

// 5. 生成 JWT Token
const token = jwt.sign(
  { id: user.id, role: user.role },
  jwtConfig.secret,
  { expiresIn: jwtConfig.expiresIn }
);

// 6. 返回响应
res.status(201).json({
  success: true,
  message: "注册成功",
  data: { token, user: user.toSafeObject() }
});
```

密码加密机制(Sequelize Model Hooks):

```javascript
// User.js Model 定义
{
  hooks: {
    beforeCreate: async (user) => {
      if (user.password) {
        user.password = await bcrypt.hash(user.password, 10);
      }
    },
    beforeUpdate: async (user) => {
      if (user.changed("password")) {
        user.password = await bcrypt.hash(user.password, 10);
      }
    }
  }
}
```

**3. 接口定义**

| 项目 | 内容 |
|------|------|
| **请求方法** | POST |
| **请求路径** | `/api/auth/register` |
| **请求头** | `Content-Type: application/json` |
| **请求参数** | `{ username: string, email?: string, password: string, nickname?: string }` |
| **参数验证** | - username: 必填,3-50字符,唯一<br>- email: 可选,邮箱格式,唯一<br>- password: 必填,6-20字符<br>- nickname: 可选,默认为 username |
| **成功响应** | `{ success: true, message: "注册成功", data: { token: string, user: {...} } }` |
| **失败响应** | `{ success: false, message: "用户名已存在" }` (400)<br>`{ success: false, message: "邮箱已存在" }` (400) |

**4. 关键代码**

**后端控制器** (`server/controllers/authController.js`):

```javascript
exports.register = async (req, res, next) => {
  try {
    const { username, email, password, nickname } = req.body;

    // 检查用户名是否已存在
    const existingUsername = await User.findOne({
      where: { username },
    });

    if (existingUsername) {
      return res.status(400).json({
        success: false,
        message: "用户名已存在，请重新输入",
      });
    }

    // 检查邮箱是否已存在
    if (email) {
      const existingEmail = await User.findOne({
        where: { email },
      });

      if (existingEmail) {
        return res.status(400).json({
          success: false,
          message: "邮箱已存在",
        });
      }
    }

    // 创建用户
    const user = await User.create({
      id: Date.now().toString(),
      username,
      email: email || `${username}@example.com`,
      password,
      nickname: nickname || username,
      points: 100,
      avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${username}`,
    });

    // 记录积分历史
    await PointHistory.create({
      id: `ph_${Date.now()}`,
      userId: user.id,
      points: 100,
      reason: "注册奖励",
      type: "earn",
    });

    // 生成 Token
    const token = jwt.sign(
      { id: user.id, role: user.role },
      jwtConfig.secret,
      { expiresIn: jwtConfig.expiresIn }
    );

    res.status(201).json({
      success: true,
      message: "注册成功",
      data: {
        token,
        user: user.toSafeObject(),
      },
    });
  } catch (error) {
    next(error);
  }
};
```

**User 模型** (`server/models/User.js`):

```javascript
const User = sequelize.define(
  "User",
  {
    id: {
      type: DataTypes.STRING(50),
      primaryKey: true,
    },
    username: {
      type: DataTypes.STRING(50),
      unique: true,
      allowNull: false,
    },
    password: {
      type: DataTypes.STRING(255),
      allowNull: false,
    },
    email: {
      type: DataTypes.STRING(100),
      unique: true,
      allowNull: true,
    },
    points: {
      type: DataTypes.INTEGER,
      defaultValue: 0,
    },
    role: {
      type: DataTypes.ENUM("user", "admin"),
      defaultValue: "user",
    },
    // ...其他字段
  },
  {
    hooks: {
      beforeCreate: async (user) => {
        if (user.password) {
          user.password = await bcrypt.hash(user.password, 10);
        }
      },
    },
  }
);

// 转换为安全对象（不包含密码）
User.prototype.toSafeObject = function () {
  const { password, ...safeUser } = this.toJSON();
  return safeUser;
};
```

**前端 API 调用** (`client/src/api/auth.js`):

```javascript
export async function register(data) {
  return apiClient.post('/auth/register', data);
}
```

**前端注册页面** (`client/src/views/frontend/auth/RegisterPage.vue`):

```vue
<script setup>
import { ref } from 'vue';
import { useRouter } from 'vue-router';
import { register } from '@/api/auth';
import { ElMessage } from 'element-plus';

const router = useRouter();
const formData = ref({
  username: '',
  email: '',
  password: '',
  confirmPassword: ''
});

const handleRegister = async () => {
  if (formData.value.password !== formData.value.confirmPassword) {
    ElMessage.error('两次密码输入不一致');
    return;
  }

  try {
    const { data } = await register({
      username: formData.value.username,
      email: formData.value.email,
      password: formData.value.password
    });
    
    // 存储 Token
    localStorage.setItem('token', data.token);
    localStorage.setItem('user', JSON.stringify(data.user));
    
    ElMessage.success('注册成功！');
    router.push('/');
  } catch (error) {
    ElMessage.error(error.response?.data?.message || '注册失败');
  }
};
</script>
```

---

##### 5.1.1.2 用户登录与会话管理功能

**1. 功能描述**

用户登录功能支持使用用户名或邮箱进行身份验证。系统通过 bcrypt 算法验证用户输入的密码与数据库中存储的加密密码是否匹配,验证通过后签发 JWT Token 作为会话凭证。Token 采用无状态设计,包含用户 ID 和角色信息,有效期为 7 天。系统在每次请求时通过中间件验证 Token 的有效性,实现身份认证和权限控制。登出功能通过客户端删除 Token 实现,无需服务端处理。

**2. 业务流程与代码逻辑**

用户登录的业务流程如下:

```
用户提交登录表单(用户名/邮箱 + 密码)
    ↓
前端表单验证
    ↓
发送 POST 请求到 /api/auth/login
    ↓
后端查询用户(支持用户名或邮箱)
  - WHERE username = ? OR email = ?
    ↓
用户不存在?
  → 是: 返回 401 "用户名或密码错误"
  → 否: 继续
    ↓
验证密码(bcrypt.compare)
    ↓
密码错误?
  → 是: 返回 401 "用户名或密码错误"
  → 否: 继续
    ↓
检查账号状态(是否被封禁)
    ↓
账号被封禁?
  → 是: 返回 403 "账号已被封禁"
  → 否: 继续
    ↓
生成 JWT Token
  - Payload: { id, role }
  - 密钥: JWT_SECRET
  - 过期时间: 7天
    ↓
更新用户登录信息(可选)
  - lastLoginAt: 当前时间
  - loginCount: +1
    ↓
返回 Token 和用户信息
    ↓
前端存储 Token 到 localStorage
    ↓
跳转到首页或原页面
```

Token 验证与权限校验流程:

```
客户端发送请求
  - Header: Authorization: Bearer <token>
    ↓
认证中间件(authenticate)拦截请求
    ↓
提取 Token
    ↓
验证 Token 签名(jwt.verify)
    ↓
Token 无效/过期?
  → 是: 返回 401 "认证令牌已过期"
  → 否: 继续
    ↓
解析 Payload 获取用户 ID
    ↓
查询数据库验证用户是否存在
    ↓
用户不存在?
  → 是: 返回 401 "用户不存在"
  → 否: 继续
    ↓
将用户信息挂载到 req.user
    ↓
需要管理员权限?
  → 是: 执行 requireAdmin 中间件
    → 检查 req.user.role === 'admin'
    → 否: 返回 403 "需要管理员权限"
  → 否: 继续
    ↓
执行业务逻辑
```

核心代码逻辑:

```javascript
// 1. 查询用户(支持用户名或邮箱)
const loginField = username || email;
const user = await User.findOne({
  where: {
    [Op.or]: [
      { username: loginField },
      { email: loginField }
    ]
  }
});

if (!user) {
  return res.status(401).json({
    success: false,
    message: "用户名或密码错误"
  });
}

// 2. 验证密码
const isValid = await user.validatePassword(password);
if (!isValid) {
  return res.status(401).json({
    success: false,
    message: "用户名或密码错误"
  });
}

// 3. 检查账号状态
if (user.banned) {
  return res.status(403).json({
    success: false,
    message: "账号已被封禁，请联系管理员"
  });
}

// 4. 生成 Token
const token = jwt.sign(
  { id: user.id, role: user.role },
  jwtConfig.secret,
  { expiresIn: jwtConfig.expiresIn }
);

// 5. 返回响应
res.json({
  success: true,
  message: "登录成功",
  data: { token, user: user.toSafeObject() }
});
```

密码验证方法(User Model 实例方法):

```javascript
User.prototype.validatePassword = async function (password) {
  return await bcrypt.compare(password, this.password);
};
```

认证中间件核心逻辑:

```javascript
// authenticate 中间件
exports.authenticate = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;

    // 1. 检查 Authorization Header
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({
        success: false,
        message: "未提供认证令牌"
      });
    }

    // 2. 提取 Token
    const token = authHeader.replace("Bearer ", "");

    // 3. 验证 Token
    const decoded = jwt.verify(token, jwtConfig.secret);

    // 4. 查询用户
    const user = await User.findByPk(decoded.id);
    if (!user) {
      return res.status(401).json({
        success: false,
        message: "用户不存在"
      });
    }

    // 5. 挂载用户信息
    req.user = user;
    next();
  } catch (error) {
    if (error.name === "TokenExpiredError") {
      return res.status(401).json({
        success: false,
        message: "认证令牌已过期"
      });
    }
    next(error);
  }
};

// requireAdmin 中间件
exports.requireAdmin = (req, res, next) => {
  if (req.user.role !== "admin") {
    return res.status(403).json({
      success: false,
      message: "需要管理员权限"
    });
  }
  next();
};
```

**3. 接口定义**

**登录接口**:

| 项目 | 内容 |
|------|------|
| **请求方法** | POST |
| **请求路径** | `/api/auth/login` |
| **请求头** | `Content-Type: application/json` |
| **请求参数** | `{ username?: string, email?: string, password: string }` |
| **参数验证** | - username 或 email 必须提供其一<br>- password: 必填 |
| **成功响应** | `{ success: true, message: "登录成功", data: { token: string, user: {...} } }` (200) |
| **失败响应** | `{ success: false, message: "用户名或密码错误" }` (401)<br>`{ success: false, message: "账号已被封禁" }` (403) |

**登出接口**:

| 项目 | 内容 |
|------|------|
| **请求方法** | POST |
| **请求路径** | `/api/auth/logout` |
| **请求头** | 无需 Token(客户端删除即可) |
| **成功响应** | `{ success: true, message: "登出成功" }` (200) |

**Token 刷新接口**:

| 项目 | 内容 |
|------|------|
| **请求方法** | POST |
| **请求路径** | `/api/auth/refresh` |
| **请求参数** | `{ token: string }` (旧 Token) |
| **成功响应** | `{ success: true, data: { token: string, user: {...} } }` (200) |
| **失败响应** | `{ success: false, message: "无效的令牌" }` (401) |

**获取当前用户信息**:

| 项目 | 内容 |
|------|------|
| **请求方法** | GET |
| **请求路径** | `/api/auth/me` |
| **请求头** | `Authorization: Bearer <token>` |
| **成功响应** | `{ success: true, data: { id, username, email, ... } }` (200) |
| **失败响应** | `{ success: false, message: "未提供认证令牌" }` (401) |

**4. 关键代码**

**后端登录控制器** (`server/controllers/authController.js`):

```javascript
exports.login = async (req, res, next) => {
  try {
    const { username, email, password } = req.body;

    // 支持用户名或邮箱登录
    const loginField = username || email;
    if (!loginField) {
      return res.status(400).json({
        success: false,
        message: "请提供用户名或邮箱",
      });
    }

    // 查找用户
    const user = await User.findOne({
      where: {
        [Op.or]: [
          { username: loginField },
          { email: loginField }
        ],
      },
    });

    if (!user) {
      return res.status(401).json({
        success: false,
        message: "用户名或密码错误",
      });
    }

    // 验证密码
    const isValid = await user.validatePassword(password);
    if (!isValid) {
      return res.status(401).json({
        success: false,
        message: "用户名或密码错误",
      });
    }

    // 检查账号状态
    if (user.banned) {
      return res.status(403).json({
        success: false,
        message: "账号已被封禁，请联系管理员",
      });
    }

    // 生成 Token
    const token = jwt.sign(
      { id: user.id, role: user.role },
      jwtConfig.secret,
      { expiresIn: jwtConfig.expiresIn }
    );

    res.json({
      success: true,
      message: "登录成功",
      data: {
        token,
        user: user.toSafeObject(),
      },
    });
  } catch (error) {
    next(error);
  }
};

// 登出(客户端删除 Token 即可)
exports.logout = (req, res) => {
  res.json({
    success: true,
    message: "登出成功",
  });
};

// Token 刷新
exports.refreshToken = async (req, res, next) => {
  try {
    const { token: oldToken } = req.body;

    if (!oldToken) {
      return res.status(400).json({
        success: false,
        message: "未提供令牌",
      });
    }

    // 验证旧 token(忽略过期)
    const decoded = jwt.verify(oldToken, jwtConfig.secret, {
      ignoreExpiration: true,
    });

    const user = await User.findByPk(decoded.id);
    if (!user) {
      return res.status(401).json({
        success: false,
        message: "用户不存在",
      });
    }

    // 生成新 Token
    const newToken = jwt.sign(
      { id: user.id, role: user.role },
      jwtConfig.secret,
      { expiresIn: jwtConfig.expiresIn }
    );

    res.json({
      success: true,
      message: "令牌刷新成功",
      data: {
        token: newToken,
        user: user.toSafeObject(),
      },
    });
  } catch (error) {
    next(error);
  }
};
```

**认证中间件** (`server/middleware/auth.js`):

```javascript
const jwt = require("jsonwebtoken");
const { User } = require("../models");
const jwtConfig = require("../config/jwt");

// JWT 认证中间件
exports.authenticate = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({
        success: false,
        message: "未提供认证令牌",
      });
    }

    const token = authHeader.replace("Bearer ", "");

    const decoded = jwt.verify(token, jwtConfig.secret);
    const user = await User.findByPk(decoded.id);

    if (!user) {
      return res.status(401).json({
        success: false,
        message: "用户不存在",
      });
    }

    req.user = user;
    next();
  } catch (error) {
    if (error.name === "JsonWebTokenError") {
      return res.status(401).json({
        success: false,
        message: "无效的认证令牌",
      });
    }
    if (error.name === "TokenExpiredError") {
      return res.status(401).json({
        success: false,
        message: "认证令牌已过期",
      });
    }
    next(error);
  }
};

// 管理员权限验证
exports.requireAdmin = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      message: "未认证",
    });
  }

  if (req.user.role !== "admin") {
    return res.status(403).json({
      success: false,
      message: "需要管理员权限",
    });
  }

  next();
};

// 可选认证(不强制要求登录)
exports.optionalAuth = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;

    if (authHeader && authHeader.startsWith("Bearer ")) {
      const token = authHeader.replace("Bearer ", "");
      const decoded = jwt.verify(token, jwtConfig.secret);
      const user = await User.findByPk(decoded.id);

      if (user) {
        req.user = user;
      }
    }
  } catch (error) {
    // 忽略错误，继续执行
  }
  next();
};
```

**路由配置** (`server/routes/auth.js`):

```javascript
const express = require("express");
const router = express.Router();
const authController = require("../controllers/authController");
const { authenticate } = require("../middleware/auth");

// 公开路由
router.post("/register", authController.register);
router.post("/login", authController.login);
router.post("/logout", authController.logout);
router.post("/refresh", authController.refreshToken);

// 需要认证的路由
router.get("/me", authenticate, authController.getCurrentUser);

module.exports = router;
```

**前端 API 调用** (`client/src/api/auth.js`):

```javascript
import apiClient from './index';

export async function login(data) {
  return apiClient.post('/auth/login', data);
}

export async function logout() {
  return apiClient.post('/auth/logout');
}

export async function getCurrentUser() {
  return apiClient.get('/auth/me');
}
```

**前端登录页面** (`client/src/views/frontend/auth/LoginPage.vue`):

```vue
<script setup>
import { ref } from 'vue';
import { useRouter } from 'vue-router';
import { login } from '@/api/auth';
import { useUserStore } from '@/store/user';
import { ElMessage } from 'element-plus';

const router = useRouter();
const userStore = useUserStore();

const formData = ref({
  username: '',
  password: ''
});

const handleLogin = async () => {
  try {
    const { data } = await login(formData.value);
    
    // 存储 Token 和用户信息
    localStorage.setItem('token', data.token);
    userStore.setUser(data.user);
    
    ElMessage.success('登录成功！');
    router.push('/');
  } catch (error) {
    ElMessage.error(error.response?.data?.message || '登录失败');
  }
};

const handleLogout = () => {
  localStorage.removeItem('token');
  userStore.clearUser();
  router.push('/login');
};
</script>
```

**Axios 请求拦截器** (`client/src/api/index.js`):

```javascript
import axios from 'axios';
import { ElMessage } from 'element-plus';
import router from '@/router';

const apiClient = axios.create({
  baseURL: 'http://localhost:3000/api',
  timeout: 10000
});

// 请求拦截器：自动添加 Token
apiClient.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  error => Promise.reject(error)
);

// 响应拦截器：处理 Token 过期
apiClient.interceptors.response.use(
  response => response.data,
  error => {
    if (error.response?.status === 401) {
      ElMessage.error('登录已过期，请重新登录');
      localStorage.removeItem('token');
      router.push('/login');
    }
    return Promise.reject(error);
  }
);

export default apiClient;
```

**路由守卫** (`client/src/router/index.js`):

```javascript
import { createRouter, createWebHistory } from 'vue-router';

const router = createRouter({
  history: createWebHistory(),
  routes: [/* ... */]
});

// 全局前置守卫：验证登录状态
router.beforeEach((to, from, next) => {
  const token = localStorage.getItem('token');
  
  // 需要登录的页面
  if (to.meta.requiresAuth && !token) {
    ElMessage.warning('请先登录');
    next('/login');
  } 
  // 管理员页面
  else if (to.meta.requiresAdmin) {
    const user = JSON.parse(localStorage.getItem('user') || '{}');
    if (user.role !== 'admin') {
      ElMessage.error('需要管理员权限');
      next('/');
    } else {
      next();
    }
  } 
  else {
    next();
  }
});

export default router;
```

---

#### 5.1.2 个人中心模块
**功能概述**: 修改个人信息、个人数据统计

#### 5.1.3 问卷浏览与搜索模块
**功能概述**: 问卷列表展示、个性化推荐、搜索与分类筛选

#### 5.1.4 问卷填写模块
**功能概述**: 问卷填写的交互体验设计(动画+动态跳转)、答题式问卷动画反馈

#### 5.1.5 问卷创建与编辑模块
**功能概述**: 题型配置与跳转逻辑设计、问卷编辑器架构(说明创建与编辑共用一个、草稿与发布)

#### 5.1.6 收藏与评论模块
**功能概述**: 管理收藏列表(包含收藏取消收藏)、评论管理(发布评论和删除评论)

#### 5.1.7 问卷管理模块
**功能概述**: 问卷状态设计与统一管理视图(五个状态)、发布问卷的查看收集的数据、复制问卷、回收站(删除问卷)

#### 5.1.8 积分与成就模块
**功能概述**: 获得积分徽章实现、排行榜展示

#### 5.1.9 AI个性化反馈报告模块
**功能概述**: 生成AI分析报告、报告列表(删除报告、PDF下载、在线预览)



---

### 5.2 后台管理端详细设计

#### 5.2.1 数据统计与监控模块
**功能概述**: 管理员活动日志、数据展示

#### 5.2.2 问卷管理模块
**功能概述**: 问卷状态的管理(发布问卷、下架、上架问卷、模板设置)、审核问卷(通过、不通过)

#### 5.2.3 用户管理模块
**功能概述**: 角色权限与状态控制(由于使用的统一用户信息接口实现)

#### 5.2.4 公告管理模块
**功能概述**: 公告管理(也是只有一个接口实现的)

---

### 5.3 公共设计

#### 5.3.1 数据库设计
- 数据库 ER 图
- 核心表结构设计(详见数据库文档)
- 索引设计
- 外键与关联关系

#### 5.3.2 接口设计规范
- RESTful API 规范
- 统一请求/响应格式
- 错误码设计

#### 5.3.3 安全设计
- SQL 注入防护(Sequelize ORM)
- XSS 防护
- CSRF 防护
- 密码加密(bcrypt)
- Token 认证(JWT)

#### 5.3.4 性能优化设计
- 数据库查询优化
- 缓存策略
- 前端资源优化
- 接口防抖节流

