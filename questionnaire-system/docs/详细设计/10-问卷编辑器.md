问卷编辑器
1、简要描述
（1）功能描述：问卷编辑器提供完整的问卷创建和编辑功能，支持添加多种题型（单选、多选、评分、文本）、配置跳转逻辑、设置答题模式、保存草稿和发布问卷等操作。编辑器支持自动保存、本地草稿恢复、模板加载等功能。

（2）代码逻辑：
用户进入问卷创建或编辑页面（/questionnaires/create 或 /questionnaires/edit/:id 路由），组件在 onMounted 生命周期钩子中调用 initialize 函数进行初始化。系统首先加载分类数据（getCategoriesApi），然后根据路由判断当前模式：编辑模式（路径包含 /edit/）调用 loadQuestionnaireForEdit 加载现有问卷数据，模板模式（路径包含 /template/）调用 loadTemplate 加载模板数据，新建模式调用 checkLocalDraft 检查本地草稿。系统启动自动保存功能（startAutoSave），每 30 秒自动将当前编辑内容保存到 localStorage，避免意外丢失。用户可以添加题目（addQuestion），系统根据题型生成默认结构并添加到 questions 数组，每个题目包含唯一 ID（Date.now() + 随机数）、标题、类型、选项等字段。用户可以配置题目的跳转逻辑（toggleQuestionLogic）和答题模式（toggleQuizMode），系统自动初始化 logicRules 和 correctAnswer 字段。用户点击"保存草稿"按钮，系统调用 saveAsDraft 函数，验证基本信息后调用 buildQuestionnaireData("draft") 构建问卷数据，通过 createQuestionnaire 或 updateQuestionnaire API 保存到后端，保存成功后清除本地缓存并跳转到问卷管理页面。用户点击"发布问卷"按钮，系统调用 publishQuestionnaire 函数，验证所有必填项后弹出确认对话框，管理员发布后状态为 "published"，普通用户提交后状态为 "pending"（待审核）。系统构建问卷数据时会检查是否有题目启用答题模式，设置问卷级别的 isQuizMode 标记。发布成功后，管理员跳转到后台问卷列表，普通用户跳转到个人中心的已创建问卷页面。

###问卷编辑器时序图描述
用户 → QuestionnaireEditor.vue: 进入创建/编辑页面
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 调用 initialize
useQuestionnaireEditor.js → 后端 /categories: 加载分类数据
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 判断当前模式（编辑/模板/新建）
useQuestionnaireEditor.js → localStorage: 检查本地草稿（checkLocalDraft）
useQuestionnaireEditor.js → 后端 /surveys/:id: 加载问卷数据（编辑模式）
useQuestionnaireEditor.js → QuestionnaireEditor.vue: 初始化表单数据
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 启动自动保存（每30秒）
用户 → QuestionnaireEditor.vue: 添加题目/配置选项
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 调用 addQuestion/addOption
useQuestionnaireEditor.js → questions: 更新题目数组
用户 → QuestionnaireEditor.vue: 点击"保存草稿"
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 调用 saveAsDraft
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 验证基本信息
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 构建问卷数据（status="draft"）
useQuestionnaireEditor.js → 后端 /surveys: 发送 POST/PUT 请求保存草稿
后端 /surveys → MySQL: 保存问卷到 surveys 表
useQuestionnaireEditor.js → localStorage: 清除本地缓存
useQuestionnaireEditor.js → Router: 跳转到问卷管理页面
用户 → QuestionnaireEditor.vue: 点击"发布问卷"
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 调用 publishQuestionnaire
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 验证所有必填项
useQuestionnaireEditor.js → 用户界面: 弹出确认对话框
用户 → useQuestionnaireEditor.js: 确认发布
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 构建问卷数据（status="published"/"pending"）
useQuestionnaireEditor.js → 后端 /surveys: 发送 POST/PUT 请求发布问卷
后端 /surveys → MySQL: 更新问卷状态
useQuestionnaireEditor.js → Router: 跳转到对应页面

2、接口定义
表 5-10 问卷编辑器接口表
接口名称       获取分类列表接口
接口描述       获取所有问卷分类，用于分类选择器
URL           {{baseurl}}/categories
method        GET
请求参数       无
返回参数        [{"id": "1", "name": "教育培训", "slug": "education"}, ...]

接口名称       创建问卷接口
接口描述       创建新问卷（草稿或待审核）
URL           {{baseurl}}/surveys
method        POST
请求参数       {"title": "问卷标题", "description": "描述", "category": "教育培训", "questionList": [...], "status": "draft", ...}
返回参数        {"success": true, "message": "创建成功", "data": {"id": "123"}, "pointsEarned": 10}

接口名称       更新问卷接口
接口描述       更新现有问卷内容
URL           {{baseurl}}/surveys/:id
method        PUT
请求参数       {"title": "新标题", "questionList": [...], "status": "published", ...}
返回参数        {"success": true, "message": "更新成功", "data": {...}}

接口名称       获取问卷详情接口
接口描述       获取问卷完整信息（编辑模式）
URL           {{baseurl}}/surveys/:id
method        GET
请求参数       id: 问卷ID
返回参数        {"id": "1", "title": "问卷标题", "questionList": [...], "status": "draft", ...}

3、关键代码
代码 5-10 问卷编辑器核心实现代码

// 初始化编辑器（useQuestionnaireEditor.js）
const initialize = () => {
  loadCategories(); // 加载分类数据

  // 判断编辑模式
  if (route.path.includes("/edit/")) {
    isEditMode.value = true;
    loadQuestionnaireForEdit(route.params.id);
  } else if (route.path.includes("/template/")) {
    isTemplateMode.value = true;
    loadTemplate(route.params.id);
  } else {
    checkLocalDraft(); // 检查本地草稿
  }

  startAutoSave(); // 启动自动保存（每30秒）
  window.addEventListener("beforeunload", handleBeforeUnload);
};

// 自动保存功能（useQuestionnaireEditor.js）
const startAutoSave = () => {
  autoSaveTimer.value = setInterval(() => {
    const currentData = buildQuestionnaireData("draft");
    const dataStr = JSON.stringify(currentData);

    if (dataStr !== lastSavedData.value) {
      saveToLocalStorage(currentData);
      lastSavedData.value = dataStr;
    }
  }, 30000); // 每30秒保存一次
};

// 检查本地草稿（useQuestionnaireEditor.js）
const checkLocalDraft = async () => {
  const localData = loadFromLocalStorage();
  if (localData && (localData.title || localData.questions?.length > 0)) {
    try {
      await ElMessageBox.confirm(
        "检测到有未保存的草稿，是否继续编辑？",
        "恢复草稿",
        {
          confirmButtonText: "继续编辑",
          cancelButtonText: "新建问卷",
          type: "info",
        }
      );
      loadQuestionnaireData(localData);
    } catch {
      clearLocalStorage();
    }
  }
};

// 保存草稿（useQuestionnaireEditor.js）
const saveAsDraft = async () => {
  if (!validateBasicInfo()) return;

  try {
    const questionnaireData = buildQuestionnaireData("draft");
    const { createQuestionnaire, updateQuestionnaire } = await import("@/api/questionnaire");

    if (isEditMode.value && currentQuestionnaireId.value) {
      await updateQuestionnaire(currentQuestionnaireId.value, questionnaireData);
      ElMessage.success("草稿更新成功");
    } else {
      const result = await createQuestionnaire(questionnaireData);
      if (result.pointsEarned) {
        userStore.profile.points = (userStore.profile.points || 0) + result.pointsEarned;
        ElMessage.success(`草稿保存成功！获得 ${result.pointsEarned} 积分`);
      } else {
        ElMessage.success("草稿保存成功");
      }
    }

    clearLocalStorage();
    router.push("/profile/questionnaires/created");
  } catch (error) {
    ElMessage.error("保存失败：" + error.message);
  }
};

// 发布问卷（useQuestionnaireEditor.js）
const publishQuestionnaire = async () => {
  if (!validateForm()) return;

  try {
    const statusToSet = isAdmin.value ? "published" : "pending";
    const confirmMessage = isAdmin.value
      ? "确定要发布此问卷吗？发布后将立即上线。"
      : "确定要提交此问卷进行审核吗？";

    await ElMessageBox.confirm(confirmMessage, "确认发布", {
      confirmButtonText: "确定",
      cancelButtonText: "取消",
      type: "warning",
    });

    const questionnaireData = buildQuestionnaireData(statusToSet);

    if (isEditMode.value && currentQuestionnaireId.value) {
      await apiClient.put(`/surveys/${currentQuestionnaireId.value}`, questionnaireData);
      ElMessage.success("问卷更新成功！");
    } else {
      const result = await createQuestionnaire(questionnaireData);
      ElMessage.success(`问卷已提交！获得 ${result.pointsEarned} 积分`);
    }

    clearLocalStorage();
    router.push(isAdmin.value ? "/admin/questionnaires/list" : "/profile/questionnaires/created");
  } catch (error) {
    if (error !== "cancel") {
      ElMessage.error("发布失败：" + error.message);
    }
  }
};

// 构建问卷数据（useQuestionnaireEditor.js）
const buildQuestionnaireData = (status = "draft") => {
  const formattedQuestions = questions.value.map((q, index) => ({
    ...q,
    order: index + 1,
  }));

  // 检查是否有题目启用了答题模式
  const hasQuizMode = formattedQuestions.some((q) => q.quizMode === true);

  return {
    title: questionnaireForm.title,
    description: questionnaireForm.description,
    category: questionnaireForm.category,
    duration: questionnaireForm.duration,
    tags: questionnaireForm.tags,
    questionList: formattedQuestions,
    isQuizMode: hasQuizMode,
    settings: { ...settingsForm },
    status: status,
    updatedAt: new Date().toISOString(),
  };
};
