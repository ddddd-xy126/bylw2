问卷编辑器
1、简要描述
（1）功能描述：问卷编辑器提供完整的问卷创建和编辑功能，支持添加多种题型（单选、多选、评分、文本）、配置题目跳转逻辑、设置答题模式、保存草稿和发布问卷等操作。编辑器支持自动保存、本地草稿恢复、模板加载等功能。

（2）代码逻辑：
用户进入问卷创建或编辑页面，系统调用 initialize 函数加载分类数据并判断当前模式（编辑/模板/新建），检查本地草稿后启动自动保存（每 30 秒保存到 localStorage）。用户添加题目时，系统根据题型生成默认结构并添加到 questions 数组。用户可配置跳转逻辑：点击"启用跳转逻辑"开关设置 enableLogic = true 并初始化 logicRules 数组，点击"添加跳转规则"添加规则对象 {optionId, targetQuestion, isEnd}，在下拉框选择触发选项和跳转目标（具体题目或结束问卷），系统调用 updateLogicRuleTarget 更新规则。用户也可以设置问卷为答题模式，答题模式后用户需要手动添加题目对应的答案。用户点击"保存草稿"，系统验证基本信息后构建问卷数据并通过 API 保存到后端，清除本地缓存后跳转到问卷管理页面。用户点击"发布问卷"，系统验证所有必填项并弹出确认对话框，管理员发布状态为 "published"，普通用户为 "pending"（待审核），发布成功后跳转到对应页面。

###问卷编辑器时序图描述
用户 → QuestionnaireEditor.vue: 进入创建/编辑页面
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 调用 initialize
useQuestionnaireEditor.js → 后端 /categories: 加载分类数据
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 判断当前模式（编辑/模板/新建）
useQuestionnaireEditor.js → localStorage: 检查本地草稿（checkLocalDraft）
useQuestionnaireEditor.js → 后端 /surveys/:id: 加载问卷数据（编辑模式）
useQuestionnaireEditor.js → QuestionnaireEditor.vue: 初始化表单数据
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 启动自动保存（每 30 秒）
用户 → QuestionnaireEditor.vue: 添加题目/配置选项
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 调用 addQuestion/addOption
useQuestionnaireEditor.js → questions: 更新题目数组
用户 → QuestionnaireEditor.vue: 点击"保存草稿"
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 调用 saveAsDraft
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 验证基本信息
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 构建问卷数据（status="draft"）
useQuestionnaireEditor.js → 后端 /surveys: 发送 POST/PUT 请求保存草稿
后端 /surveys → MySQL: 保存问卷到 surveys 表
useQuestionnaireEditor.js → localStorage: 清除本地缓存
useQuestionnaireEditor.js → Router: 跳转到问卷管理页面
用户 → QuestionnaireEditor.vue: 点击"发布问卷"
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 调用 publishQuestionnaire
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 验证所有必填项
useQuestionnaireEditor.js → 用户界面: 弹出确认对话框
用户 → useQuestionnaireEditor.js: 确认发布
useQuestionnaireEditor.js → useQuestionnaireEditor.js: 构建问卷数据（status="published"/"pending"）
useQuestionnaireEditor.js → 后端 /surveys: 发送 POST/PUT 请求发布问卷
后端 /surveys → MySQL: 更新问卷状态
useQuestionnaireEditor.js → Router: 跳转到对应页面

**_最新时序图描述_**
用户 → QuestionnaireEditor.vue: 进入创建/编辑页面
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 初始化编辑环境
useQuestionnaireEditor.js → 后端 API: 加载分类数据，根据模式获取问卷数据
useQuestionnaireEditor.js → localStorage: 检查本地草稿
useQuestionnaireEditor.js → 界面: 初始化表单数据，启动 30 秒自动保存

用户 → QuestionnaireEditor.vue: 编辑题目和选项
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 更新题目数组

用户 → QuestionnaireEditor.vue: 点击"保存草稿"
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 验证并构建草稿数据
useQuestionnaireEditor.js → 后端 API: 保存草稿（status="draft"）
useQuestionnaireEditor.js → localStorage: 清除本地缓存
useQuestionnaireEditor.js → 路由器: 跳转到问卷管理页面

用户 → QuestionnaireEditor.vue: 点击"发布问卷"
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 验证必填项并弹出确认框
用户 → useQuestionnaireEditor.js: 确认发布
useQuestionnaireEditor.js → 后端 API: 发布问卷（status="published"/"pending"）
useQuestionnaireEditor.js → 路由器: 跳转到对应页面
**_end_**

2、接口定义
表 5-10 问卷编辑器接口表

接口名称 获取分类列表接口
接口描述 获取所有问卷分类，用于分类选择器
URL {{baseurl}}/categories
method GET
请求参数 无
返回参数 [{"id": "1", "name": "教育培训", "slug": "education"}, ...]

接口名称 创建问卷接口
接口描述 创建新问卷（草稿或待审核）
URL {{baseurl}}/surveys
method POST
请求参数 {"title": "问卷标题", "description": "描述", "category": "教育培训", "questionList": [...], "status": "draft", ...}
返回参数 {"success": true, "message": "创建成功", "data": {"id": "123"}, "pointsEarned": 10}

接口名称 更新问卷接口
接口描述 更新现有问卷内容
URL {{baseurl}}/surveys/:id
method PUT
请求参数 {"title": "新标题", "questionList": [...], "status": "published", ...}
返回参数 {"success": true, "message": "更新成功", "data": {...}}

接口名称 获取问卷详情接口
接口描述 获取问卷完整信息（编辑模式）
URL {{baseurl}}/surveys/:id
method GET
请求参数 id: 问卷 ID
返回参数 {"id": "1", "title": "问卷标题", "questionList": [...], "status": "draft", ...}

3、关键代码
代码 5-10 问卷编辑器核心代码

// 跳转逻辑配置（useQuestionnaireEditor.js）
const updateLogicRuleTarget = (questionId, ruleIndex, target) => {
const question = questions.value.find((q) => q.id === questionId);
if (question && question.logicRules && question.logicRules[ruleIndex]) {
if (target === "end") {
question.logicRules[ruleIndex].isEnd = true;
question.logicRules[ruleIndex].targetQuestion = null;
} else {
question.logicRules[ruleIndex].isEnd = false;
question.logicRules[ruleIndex].targetQuestion = target;
}
}
};

// 发布问卷（useQuestionnaireEditor.js）
const publishQuestionnaire = async () => {
if (!validateForm()) return;

const statusToSet = isAdmin.value ? "published" : "pending";
const questionnaireData = buildQuestionnaireData(statusToSet);

if (isEditMode.value && currentQuestionnaireId.value) {
await apiClient.put(`/surveys/${currentQuestionnaireId.value}`, questionnaireData);
} else {
const result = await apiClient.post('/surveys', questionnaireData);
if (result.pointsEarned) {
userStore.profile.points += result.pointsEarned;
}
}

clearLocalStorage();
router.push(isAdmin.value ? "/admin/questionnaires" : "/profile/questionnaires/created");
};
