问卷填写逻辑跳转
1、简要描述
（1）功能描述：答题者在填写问卷时，系统根据其选择的答案自动执行跳转逻辑，动态跳转到指定题目或直接结束问卷，实现个性化的问卷流程。跳转规则由问卷创建者预先配置（详见"问卷编辑器"章节），包含触发条件（选择的选项）和跳转目标（题目序号或结束问卷）。

（2）代码逻辑：
用户在问卷详情点击开始测试，进入问卷太难写流程，在填写问卷点击"下一题"时，系统调用 nextQuestion 函数检查当前题目是否启用跳转逻辑（enableLogic）和配置了跳转规则（logicRules）。若启用，获取用户答案并遍历跳转规则查找匹配项：单选题比较 optionId 与答案是否相等，多选题检查答案数组是否包含 optionId。找到匹配规则后，若 isEnd 为 true 则返回 "complete" 提交问卷，否则跳转到 targetQuestion 指定题目并返回 "jumped"。若无匹配规则则正常进入下一题返回 "next"。系统通过 computeExpectedPath 函数预先模拟完整答题路径，进度条基于预期路径计算，验证必答题时只检查路径上的题目。

###问卷填写逻辑跳转时序图描述
答题者 → AnswerPage.vue: 进入问卷填写页面（/answer/:id）
AnswerPage.vue → 后端路由 (GET /surveys/:id): 获取问卷详情
后端路由 → surveyController.js: 调用 getSurveyById 方法
surveyController.js → MySQL: 查询 surveys 表获取问卷数据（包含跳转规则）
MySQL → surveyController.js: 返回问卷数据
surveyController.js → AnswerPage.vue: 返回问卷详情（questionList 包含 enableLogic 和 logicRules）
AnswerPage.vue → useQuestionnaireLogic.js: 初始化问卷逻辑，加载题目列表
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 调用 computeExpectedPath 计算预期答题路径
答题者 → AnswerPage.vue: 选择答案后点击"下一题"按钮
AnswerPage.vue → useQuestionnaireLogic.js: 调用 nextQuestion 函数
useQuestionnaireLogic.js → currentQuestion.value: 获取当前题目对象
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 检查 question.enableLogic 是否为 true
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 检查 question.logicRules 是否存在且长度 > 0
useQuestionnaireLogic.js → answers.value: 获取当前题目的用户答案
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 遍历 logicRules 数组查找匹配规则
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 单选题比较 rule.optionId === userAnswer
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 多选题检查 userAnswer.includes(rule.optionId)
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 找到匹配规则，检查 matchedRule.isEnd
useQuestionnaireLogic.js → AnswerPage.vue: 返回跳转结果（"complete" / "jumped" / "next"）
AnswerPage.vue → AnswerPage.vue: 根据返回值执行操作
AnswerPage.vue → AnswerPage.vue: "complete" → 提交问卷
AnswerPage.vue → AnswerPage.vue: "jumped" → 更新 currentQuestionIndex 到目标题目
AnswerPage.vue → AnswerPage.vue: "next" → currentQuestionIndex++
AnswerPage.vue → 答题者界面: 更新显示（跳转题目 / 提交问卷 / 下一题）

**_最新时序图描述_**
答题者 → AnswerPage.vue: 进入问卷填写页面
AnswerPage.vue → 后端 API: 获取问卷详情（含跳转规则）
后端 API → MySQL: 查询问卷数据
MySQL → 后端 API: 返回问卷数据
后端 API → AnswerPage.vue: 返回问卷详情（含 logicRules）
AnswerPage.vue → useQuestionnaireLogic.js: 初始化问卷逻辑和预期路径

答题者 → AnswerPage.vue: 选择答案后点击"下一题"
AnswerPage.vue → useQuestionnaireLogic.js: 调用 nextQuestion 函数
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 检查当前题目的 enableLogic 和 logicRules
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 匹配用户答案与跳转规则
useQuestionnaireLogic.js → AnswerPage.vue: 返回跳转结果（"complete"/"jumped"/"next"）
AnswerPage.vue → AnswerPage.vue: 根据结果执行操作
AnswerPage.vue → 答题者界面: 更新显示（跳转/提交/下一题）

**_end_**

2、接口定义
表 5-9 问卷填写逻辑跳转接口表

接口名称 获取问卷详情接口
接口描述 答题者获取问卷完整信息，包括题目和跳转规则配置
URL {{baseurl}}/surveys/:id
method GET
请求参数 {"id": "survey_123"}
返回参数 {"success": true, "data": {"id": "survey_123", "title": "用户满意度调查", "questionList": [{"id": "q1", "type": "single", "title": "您对产品满意吗？", "options": [{"id": "opt1", "text": "满意"}, {"id": "opt2", "text": "不满意"}], "enableLogic": true, "logicRules": [{"optionId": "opt2", "targetQuestion": 5, "isEnd": false}]}, {...}]}}

接口名称 提交答案接口
接口描述 提交问卷答案（跳转逻辑在前端执行，不影响提交）
URL {{baseurl}}/answers
method POST
请求参数 {"surveyId": "survey_123", "answers": {"q1": "opt2", "q5": "..."}, "duration": 120, "score": 85}
返回参数 {"success": true, "message": "答案提交成功", "data": {"answerId": "ans_456", "pointsEarned": 10}}

3、关键代码
代码 5-9 问卷填写逻辑跳转核心实现代码

// 下一题跳转逻辑处理（useQuestionnaireLogic.js）
const nextQuestion = (questionList) => {
const qs = questionList || questions.value;
const question = currentQuestion.value;

// 检查跳转逻辑
if (question?.enableLogic && question.logicRules && question.logicRules.length > 0) {
const userAnswer = answers.value[question.id];
let matchedRule = null;

    // 单选题：直接比较选项ID
    if (question.type === "single") {
      matchedRule = question.logicRules.find(
        (rule) => rule.optionId === userAnswer
      );
    }
    // 多选题：检查答案数组是否包含选项ID
    else if (question.type === "multiple" && Array.isArray(userAnswer)) {
      matchedRule = question.logicRules.find((rule) =>
        userAnswer.includes(rule.optionId)
      );
    }

    if (matchedRule) {
      // 检查是否选择了"结束问卷"
      if (matchedRule.isEnd) {
        return "complete";
      }

      // 跳转到指定题目
      const targetIndex = matchedRule.targetQuestion - 1;
      if (targetIndex >= 0 && targetIndex < totalQuestions.value) {
        currentQuestionIndex.value = targetIndex;
        return "jumped";
      }
    }

}

// 正常进入下一题
if (isLastQuestion.value) {
return "complete";
} else {
currentQuestionIndex.value++;
return "next";
}
};

// 计算预期路径（computeExpectedPath）
const computeExpectedPath = () => {
const orderedQuestions = getOrderedQuestions();
const path = [];
const seen = new Set();
let idx = 0;

while (idx >= 0 && idx < orderedQuestions.length) {
const q = orderedQuestions[idx];
if (!q || seen.has(String(q.id))) break;
path.push(String(q.id));
seen.add(String(q.id));

    // 检查跳转逻辑
    if (q.enableLogic && q.logicRules && q.logicRules.length > 0) {
      const userAnswer = committedAnswers.value[q.id];
      let matchedRule = null;

      if (q.type === "single") {
        matchedRule = q.logicRules.find(
          (rule) => rule.optionId === userAnswer
        );
      } else if (q.type === "multiple" && Array.isArray(userAnswer)) {
        matchedRule = q.logicRules.find((rule) =>
          userAnswer.includes(rule.optionId)
        );
      }

      if (matchedRule) {
        // 如果规则标记为结束问卷，路径到此为止
        if (matchedRule.isEnd) {
          break;
        }

        // 跳转到指定题目
        const targetIndex = matchedRule.targetQuestion - 1;
        if (targetIndex >= 0 && targetIndex < orderedQuestions.length) {
          idx = targetIndex;
          continue;
        } else {
          break;
        }
      }
    }

    idx++;

}

return path;
};
