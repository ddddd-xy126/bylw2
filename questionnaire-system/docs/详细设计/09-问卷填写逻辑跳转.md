问卷填写逻辑跳转
1、简要描述
（1）功能描述：问卷填写支持逻辑跳转功能,允许根据用户的答案选择动态跳转到指定题目或直接结束问卷。创建者可以为单选题和多选题设置跳转规则,当用户选择特定选项时触发跳转逻辑。

（2）代码逻辑：
问卷创建者在编辑问卷时,为题目启用跳转逻辑（enableLogic = true）并配置跳转规则（logicRules 数组）。每条规则包含三个字段：optionId（触发选项ID）、targetQuestion（目标题目序号）、isEnd（是否结束问卷）。用户在答题页面选择答案后点击"下一题"按钮,系统调用 nextQuestion 函数执行跳转逻辑。系统首先检查当前题目是否启用了跳转逻辑（question.enableLogic 和 question.logicRules），然后获取用户答案，遍历跳转规则查找匹配项：单选题直接比较 rule.optionId 与用户答案，多选题检查用户答案数组是否包含 rule.optionId。如果找到匹配规则，系统检查 isEnd 字段：若为 true 则返回 "complete" 标记问卷完成，若为 false 则跳转到 targetQuestion 指定的题目序号（targetQuestion - 1 为数组索引）。如果未找到匹配规则或未启用跳转逻辑，系统正常进入下一题。进度计算基于预期路径（expectedPath）,系统通过 computeExpectedPath 函数模拟用户的完整答题路径,遇到跳转规则时自动计算跳转后的路径,确保进度条准确反映实际需要回答的题目数量。验证必答题时,系统只验证预期路径上的题目,跳过不在路径中的题目。

###问卷填写逻辑跳转时序图描述
创建者 → QuestionnaireEditor.vue: 为题目启用跳转逻辑
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 调用 toggleQuestionLogic 设置 enableLogic
useQuestionnaireEditor.js → QuestionnaireEditor.vue: 初始化 logicRules 数组
创建者 → QuestionnaireEditor.vue: 添加跳转规则
QuestionnaireEditor.vue → useQuestionnaireEditor.js: 调用 addLogicRule
useQuestionnaireEditor.js → logicRules: 添加规则 {optionId, targetQuestion, isEnd}
创建者 → QuestionnaireEditor.vue: 保存问卷
QuestionnaireEditor.vue → 后端 /surveys: 发送 POST/PUT 请求
后端 /surveys → MySQL: 保存问卷和跳转规则到 surveys 表
用户 → AnswerPage.vue: 填写问卷选择答案
用户 → AnswerPage.vue: 点击"下一题"
AnswerPage.vue → useQuestionnaireLogic.js: 调用 nextQuestion
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 检查 enableLogic 和 logicRules
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 获取用户答案并遍历规则
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 查找匹配的跳转规则
useQuestionnaireLogic.js → useQuestionnaireLogic.js: 检查 isEnd 字段
useQuestionnaireLogic.js → AnswerPage.vue: 返回跳转结果（complete/jumped/next）
AnswerPage.vue → AnswerPage.vue: 根据结果更新 currentQuestionIndex 或提交问卷

2、接口定义
表 5-9 问卷填写逻辑跳转接口表
接口名称       获取问卷详情接口
接口描述       获取问卷的完整信息，包括跳转规则配置
URL           {{baseurl}}/surveys/:id
method        GET
请求参数       id: 问卷ID
返回参数        {"id": "1", "questions": [{"id": "1", "enableLogic": true, "logicRules": [{"optionId": "a1", "targetQuestion": 3, "isEnd": false}], ...}], ...}

接口名称       创建/更新问卷接口
接口描述       保存问卷及其跳转规则配置
URL           {{baseurl}}/surveys 或 {{baseurl}}/surveys/:id
method        POST 或 PUT
请求参数       {"title": "问卷标题", "questions": [{"enableLogic": true, "logicRules": [...], ...}], ...}
返回参数        {"success": true, "message": "保存成功", "data": {"id": "123", ...}}

3、关键代码
代码 5-9 问卷填写逻辑跳转核心实现代码

// 跳转逻辑处理（useQuestionnaireLogic.js）
const nextQuestion = (questionList) => {
  const qs = questionList || questions.value;
  const question = currentQuestion.value;

  // 检查跳转逻辑
  if (question?.enableLogic && question.logicRules && question.logicRules.length > 0) {
    const userAnswer = answers.value[question.id];
    let matchedRule = null;

    // 单选题：直接比较选项ID
    if (question.type === "single") {
      matchedRule = question.logicRules.find(
        (rule) => rule.optionId === userAnswer
      );
    } 
    // 多选题：检查答案数组是否包含选项ID
    else if (question.type === "multiple" && Array.isArray(userAnswer)) {
      matchedRule = question.logicRules.find((rule) =>
        userAnswer.includes(rule.optionId)
      );
    }

    if (matchedRule) {
      // 检查是否选择了"结束问卷"
      if (matchedRule.isEnd) {
        return "complete";
      }

      // 跳转到指定题目
      const targetIndex = matchedRule.targetQuestion - 1;
      if (targetIndex >= 0 && targetIndex < totalQuestions.value) {
        currentQuestionIndex.value = targetIndex;
        return "jumped";
      }
    }
  }

  // 正常进入下一题
  if (isLastQuestion.value) {
    return "complete";
  } else {
    currentQuestionIndex.value++;
    return "next";
  }
};

// 计算预期路径（computeExpectedPath）
const computeExpectedPath = () => {
  const orderedQuestions = getOrderedQuestions();
  const path = [];
  const seen = new Set();
  let idx = 0;

  while (idx >= 0 && idx < orderedQuestions.length) {
    const q = orderedQuestions[idx];
    if (!q || seen.has(String(q.id))) break;
    path.push(String(q.id));
    seen.add(String(q.id));

    // 检查跳转逻辑
    if (q.enableLogic && q.logicRules && q.logicRules.length > 0) {
      const userAnswer = committedAnswers.value[q.id];
      let matchedRule = null;

      if (q.type === "single") {
        matchedRule = q.logicRules.find(
          (rule) => rule.optionId === userAnswer
        );
      } else if (q.type === "multiple" && Array.isArray(userAnswer)) {
        matchedRule = q.logicRules.find((rule) =>
          userAnswer.includes(rule.optionId)
        );
      }

      if (matchedRule) {
        // 如果规则标记为结束问卷，路径到此为止
        if (matchedRule.isEnd) {
          break;
        }

        // 跳转到指定题目
        const targetIndex = matchedRule.targetQuestion - 1;
        if (targetIndex >= 0 && targetIndex < orderedQuestions.length) {
          idx = targetIndex;
          continue;
        } else {
          break;
        }
      }
    }

    idx++;
  }

  return path;
};

// 跳转规则配置（QuestionnaireEditor.vue）
const addLogicRule = (questionId) => {
  const question = questions.value.find((q) => q.id === questionId);
  if (!question.logicRules) {
    question.logicRules = [];
  }

  question.logicRules.push({
    optionId: null,
    targetQuestion: null,
    isEnd: false,
  });
};

const updateLogicRuleTarget = (questionId, ruleIndex, target) => {
  const question = questions.value.find((q) => q.id === questionId);
  if (question && question.logicRules && question.logicRules[ruleIndex]) {
    if (target === "end") {
      question.logicRules[ruleIndex].isEnd = true;
      question.logicRules[ruleIndex].targetQuestion = null;
    } else {
      question.logicRules[ruleIndex].isEnd = false;
      question.logicRules[ruleIndex].targetQuestion = target;
    }
  }
};
