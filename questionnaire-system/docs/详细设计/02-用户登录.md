用户登录
1、简要描述
（1）功能描述：用户登录功能支持使用用户名或邮箱进行身份验证。系统通过 bcrypt 算法验证用户输入的密码与数据库中存储的加密密码是否匹配，验证通过后签发 JWT Token 作为会话凭证。Token 采用无状态设计，包含用户 ID 和角色信息，有效期为 7 天。系统在每次请求时通过中间件验证 Token 的有效性，实现身份认证和权限控制。登录成功后，系统会根据用户角色自动跳转到对应页面（管理员跳转到后台仪表板，普通用户跳转到首页），并检查是否有被退回的问卷进行提醒。

（2）代码逻辑：
用户在登录页面的对应输入框内，填写用户名或邮箱和密码，点击登录按钮，前端验证必填字段后，立即将用户填写的数据通过 HTTP 请求传输到后端服务器。后端服务器接收到用户所填数据后，会先进行格式验证，确保信息符合既定格式规范。验证通过后，系统根据用户名或邮箱查询数据库，获取用户记录。若用户不存在，向前端返回"用户名或密码错误"的提示信息。若用户存在，系统使用 bcrypt 算法验证用户输入的密码与数据库中存储的加密密码是否匹配。密码验证失败则返回相同的错误提示（避免泄露用户是否存在的信息）。密码验证成功后，系统检查用户账号状态，若账号被封禁则返回封禁提示。通过所有验证后，系统生成 JWT Token（包含用户 ID 和角色信息，有效期 7 天），并将 Token 和用户信息返回给前端。前端接收到成功响应后，将 Token 存储到 localStorage，将用户信息存储到 Pinia 状态管理中，并触发登录后的业务逻辑（如首次登录奖励、每日登录积分、退回问卷提醒等）。最后，系统根据用户角色自动跳转到相应页面（管理员跳转到 /admin/dashboard，普通用户跳转到 /home）。

###用户登录时序图描述
用户 → LoginPage.vue: 填写用户名/邮箱和密码，点击登录
LoginPage.vue → 后端API: 调用login API发送登录请求
后端API → MySQL: 查询用户信息
MySQL → 后端API: 返回用户记录
后端API → 后端API: 验证密码，检查账号状态
后端API → 后端API: 生成JWT Token（有效期7天）
后端API → LoginPage.vue: 返回登录成功响应（Token和用户信息）
LoginPage.vue → localStorage: 存储JWT Token
LoginPage.vue → Pinia store: 存储用户信息
LoginPage.vue → LoginPage.vue: 执行登录后业务逻辑（积分奖励、退回问卷提醒）
LoginPage.vue → 用户界面: 根据用户角色跳转页面（管理员→/admin/dashboard，普通用户→/home）

2、接口定义
表 5-2 用户登录接口表
接口名称 登录接口
接口描述 用户点击登录时调用接口，验证身份并签发 Token
URL {{baseurl}}/auth/login
method POST
请求参数 {"username": "testuser","password": "password123"}
返回参数 {"success": true, "message": "登录成功", "data": {"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", "user": {"id": "123", "username": "testuser", "role": "user"}}}

3、关键代码
代码 5-2 用户登录核心实现代码
// 前端调用登录接口
export async function login(data) {
const response = await apiClient.post("/auth/login", {
username: data.username || data.email,
password: data.password,
});
return response;
}

// 后端登录控制器
exports.login = async (req, res, next) => {
try {
const { username, email, password } = req.body;

    // 支持用户名或邮箱登录
    const loginField = username || email;
    if (!loginField) {
      return res.status(400).json({
        success: false,
        message: "请提供用户名或邮箱",
      });
    }

    // 查找用户（支持用户名或邮箱）
    const user = await User.findOne({
      where: {
        [Op.or]: [{ username: loginField }, { email: loginField }],
      },
    });

    if (!user) {
      return res.status(401).json({
        success: false,
        message: "用户名或密码错误",
      });
    }

    // 验证密码（使用 bcrypt 比对）
    const isValid = await user.validatePassword(password);
    if (!isValid) {
      return res.status(401).json({
        success: false,
        message: "用户名或密码错误",
      });
    }

    // 检查账号状态
    if (user.banned) {
      return res.status(403).json({
        success: false,
        message: "账号已被封禁，请联系管理员",
      });
    }

    // 生成 JWT Token
    const token = jwt.sign(
      { id: user.id, role: user.role },
      jwtConfig.secret,
      { expiresIn: jwtConfig.expiresIn }
    );

    res.json({
      success: true,
      message: "登录成功",
      data: {
        token,
        user: user.toSafeObject(),
      },
    });

} catch (error) {
next(error);
}
};

// 前端登录提交逻辑
const submitLogin = async () => {
loginLoading.value = true;
try {
const response = await loginAuth(loginForm);
const { token, user } = response.data || response;

    // 存储 Token 和用户信息
    userStore.setToken(token);
    userStore.setProfile(user);

    ElMessage.success("登录成功！");

    // 处理登录后的首次/非首次逻辑
    await userStore.handlePostLogin();

    // 检查是否有被退回的问卷
    await checkRejectedSurveys(user);

    // 根据角色跳转
    if (user?.role === "admin") {
      router.push("/admin/dashboard");
    } else {
      router.push("/home");
    }

} catch (error) {
console.error("登录失败:", error);
ElMessage.error(error.message || "登录失败，请重试");
} finally {
loginLoading.value = false;
}
};

// User 模型密码验证方法
User.prototype.validatePassword = async function (password) {
return await bcrypt.compare(password, this.password);
};
