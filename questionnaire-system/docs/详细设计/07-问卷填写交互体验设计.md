问卷填写交互体验设计
1、简要描述
（1）功能描述：问卷填写页面提供丰富的交互动画和视觉反馈，提升用户答题体验。页面包含三个核心动画模块：选项交互动画（逐个滑入、透明度渐显、鼠标悬停抬升、点击粒子爆发特效）和右侧进度条动画（随机展示液体填充、树木生长、圆形进度三种动画之一）。

（2）代码逻辑：
用户进入问卷填写页面后，组件在 onMounted 生命周期钩子中加载问卷数据并初始化答题逻辑。页面分为三个区域：左侧统计区域显示答题统计信息，中间题目区域使用 AnimatedQuestion 组件展示当前题目，右侧进度区域使用 ProgressCard 和 RandomProgress 组件展示动态进度动画。AnimatedQuestion 组件根据题目类型（单选、多选、评分、文本）渲染不同的交互动画：单选题选项从左侧逐个滑入（slideInLeft 动画，每个选项延迟 0.1s），鼠标悬停时选项向右移动 8px 并放大 1.02 倍，点击时触发粒子爆发特效（6 个粒子从选项中心向外扩散）；多选题选项采用交错滑入动画（每个选项延迟 0.08s），选中时显示勾选图标的弹跳动画和波纹效果；评分题采用星星光晕效果，点击时触发缩放动画。RandomProgress 组件通过对问卷 ID 进行哈希计算，确保同一问卷始终显示同一种进度动画：DynamicProgress 实现圆形进度条（SVG 渐变色圆环，带发光滤镜），LiquidFill 实现液体填充效果（Canvas 绘制波浪动画和气泡效果），TreeGrowth 实现树木生长动画（递归生成树枝，根据进度绘制叶子）。用户答题时，系统实时更新答题进度，进度动画同步更新百分比。用户点击"下一题"或"提交问卷"按钮时，系统验证当前题目是否已答（必答题必须作答），验证通过后切换到下一题或提交问卷。

###问卷填写交互体验时序图描述
用户 → AnswerPage.vue: 进入问卷填写页面（/surveys/answer/:id）
AnswerPage.vue → AnswerPage.vue: onMounted 生命周期钩子加载问卷数据
AnswerPage.vue → 后端 /surveys/:id: 发送 GET 请求获取问卷详情
后端 /surveys/:id → surveyController.js: 调用 getSurveyById 方法
surveyController.js → MySQL: 查询 surveys 表
MySQL → surveyController.js: 返回问卷数据
surveyController.js → AnswerPage.vue: 返回问卷详情
AnswerPage.vue → useQuestionnaireLogic.js: 初始化答题逻辑
AnswerPage.vue → AnimatedQuestion.vue: 渲染当前题目和交互动画
AnimatedQuestion.vue → AnimatedQuestion.vue: 根据题目类型应用动画（滑入、悬停、点击）
AnswerPage.vue → RandomProgress.vue: 渲染进度动画（哈希选择动画类型）
RandomProgress.vue → DynamicProgress / LiquidFill / TreeGrowth: 渲染对应的进度组件
用户 → AnimatedQuestion.vue: 选择答案
AnimatedQuestion.vue → AnimatedQuestion.vue: 触发交互动画（粒子爆发、波纹、光晕）
AnimatedQuestion.vue → AnswerPage.vue: 更新答案数据
AnswerPage.vue → RandomProgress.vue: 更新进度百分比
RandomProgress.vue → 进度组件: 更新动画进度
用户 → AnswerPage.vue: 点击"下一题"或"提交问卷"
AnswerPage.vue → AnswerPage.vue: 验证必答题
AnswerPage.vue → AnswerPage.vue: 切换到下一题或提交问卷

***最新时序图描述***
用户 → AnswerPage.vue: 进入问卷填写页面
AnswerPage.vue → 后端API: 获取问卷详情
后端API → MySQL: 查询问卷数据
MySQL → 后端API: 返回问卷详情
后端API → AnswerPage.vue: 返回问卷数据
AnswerPage.vue → useQuestionnaireLogic: 初始化答题逻辑
AnswerPage.vue → AnimatedQuestion.vue: 渲染题目并显示滑入动画
AnswerPage.vue → RandomProgress.vue: 渲染进度组件
RandomProgress.vue → 动态选择动画组件: 基于哈希值选择动画类型（DynamicProgress/LiquidFill/TreeGrowth）
动态选择动画组件 → 用户界面: 显示相应进度动画

用户 → AnimatedQuestion.vue: 点击选择答案
AnimatedQuestion.vue → AnimatedQuestion.vue: 触发交互动画效果（粒子爆发/波纹/光晕）
AnimatedQuestion.vue → AnswerPage.vue: 更新答案数据
AnswerPage.vue → RandomProgress.vue: 更新进度百分比
RandomProgress.vue → 动态选择动画组件: 更新动画进度

用户 → AnswerPage.vue: 点击下一题或提交
AnswerPage.vue → AnswerPage.vue: 验证必答题
AnswerPage.vue → AnimatedQuestion.vue: 显示题目切换动画
AnswerPage.vue → 用户界面: 提交问卷或切换到下一题
***end***

2、接口定义
表 5-7 问卷填写交互体验接口表
接口名称       获取问卷详情接口
接口描述       获取问卷的完整信息，包括题目列表、选项、类型等
URL           {{baseurl}}/surveys/:id
method        GET
请求参数       id: 问卷ID
返回参数        {"id": "1", "title": "问卷标题", "questions": [{"id": "1", "title": "题目", "type": "single", "options": [...], "required": true, ...}], ...}

接口名称       提交问卷答案接口
接口描述       用户完成答题后提交所有答案
URL           {{baseurl}}/surveys/:id/submit
method        POST
请求参数       {"answers": {"q1": "a1", "q2": ["a2", "a3"], ...}, "elapsedTime": 120}
返回参数        {"success": true, "message": "提交成功", "recordId": "123"}

3、关键代码
代码 5-7 问卷填写交互体验核心实现代码

// 选项滑入动画（AnimatedQuestion.vue）
.animated-option {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  animation: slideInLeft 0.5s ease-out backwards;
  animation-delay: var(--delay); // 每个选项延迟 0.1s

  &:hover {
    border-color: var(--color-primary-light-3);
    transform: translateX(8px) scale(1.02); // 悬停抬升
    box-shadow: 0 8px 16px rgba(64, 158, 255, 0.15);
  }

  &.selected {
    border-color: var(--color-primary);
    animation: selectBounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  }
}

// 粒子爆发特效（AnimatedQuestion.vue）
.particle-effect {
  .particle {
    background: var(--color-primary-light-3);
    animation: particleBurst 0.8s ease-out forwards;

    @for $i from 1 through 6 {
      &:nth-child(#{$i}) {
        --angle: #{$i * 60}deg;
        animation-delay: #{$i * 0.05}s;
      }
    }
  }
}

@keyframes particleBurst {
  0% { transform: translate(0, 0) scale(1); opacity: 1; }
  100% {
    transform: translate(
      calc(cos(var(--angle)) * 40px),
      calc(sin(var(--angle)) * 40px)
    ) scale(0);
    opacity: 0;
  }
}

// 随机进度动画选择（RandomProgress.vue）
const hashString = (str) => {
  if (str == null) return Math.floor(Math.random() * 1000);
  let h = 5381;
  for (let i = 0; i < str.length; i++) {
    h = ((h << 5) + h) + str.charCodeAt(i);
  }
  return Math.abs(h);
};

const selected = computed(() => {
  const list = ['dynamic', 'tree', 'liquid'];
  const idStr = props.questionnaireId != null ? String(props.questionnaireId) : String(Math.random());
  const idx = hashString(idStr) % list.length;
  return list[idx]; // 返回 'dynamic'（圆形）、'tree'（树木）或 'liquid'（液体）
});

// 液体填充动画（LiquidFill.vue）
function drawWave(wave, baseY, alpha) {
  const w = c.clientWidth;
  const cx = w / 2, r = Math.min(w, c.clientHeight) / 2 - 10;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = 'rgba(100,200,255,0.6)';
  ctx.beginPath();
  ctx.moveTo(cx - r, baseY);
  
  for (let x = cx - r; x <= cx + r; x += 5) {
    const offset = wave.amp * Math.sin((x - cx) / wave.len + wave.phase);
    ctx.lineTo(x, baseY + offset);
  }
  
  ctx.lineTo(cx + r, cy + r);
  ctx.lineTo(cx - r, cy + r);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// 树木生长动画（TreeGrowth.vue）
function drawLeaves(progress) {
  const leafLevel = branchLevels[maxGen];
  const count = Math.floor(progress * leafLevel.length);
  
  for (let i = 0; i < count; i++) {
    const b = leafLevel[i];
    const x2 = b.x + Math.cos(b.angle) * b.len;
    const y2 = b.y + Math.sin(b.angle) * b.len;
    
    ctx.beginPath();
    ctx.arc(x2, y2, 3 + Math.random() * 2, 0, Math.PI * 2);
    ctx.fill();
  }
}
